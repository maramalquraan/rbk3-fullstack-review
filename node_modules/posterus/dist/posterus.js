"use strict";

var _createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var Queue = require("fastqueue");

exports.isFuture = isFuture;

function isFuture(value) {
    return isObject(value) && isFunction(value.settle) && isFunction(value.map) && isFunction(value.mapResult) && isFunction(value.mapError) && isFunction(value.deinit);
}

var Scheduler = function() {
    function Scheduler() {
        _classCallCheck(this, Scheduler);
        this.a = new Queue();
        this.b = false;
        this.c = onScheduledTick.bind(null, this);
        this.asap = chooseAsapImplementation(this.c);
    }
    Scheduler.prototype.push = function push(future) {
        this.a.push(future);
        if (this.a.length) scheduleTick(this);
    };
    Scheduler.prototype.tick = function tick() {
        try {
            while (this.a.length) {
                this.a.shift().finishPending();
            }
        } finally {
            if (this.a.length) scheduleTick(this);
        }
    };
    Scheduler.prototype.deinit = function deinit() {
        this.a = new Queue();
    };
    return Scheduler;
}();

exports.Scheduler = Scheduler;

function scheduleTick(scheduler) {
    if (!scheduler.b) {
        scheduler.b = true;
        scheduler.asap.call(null, scheduler.c);
    }
}

function onScheduledTick(scheduler) {
    scheduler.b = false;
    scheduler.tick();
}

var _UNSET_ALL = 0 | 0;

var PENDING = 1 | 0;

var ERROR = 2 | 0;

var SUCCESS = 4 | 0;

var AVERTED = 8 | 0;

var PENDING_REJECTION = 16 | 0;

var CONSUMED = 32 | 0;

var MAPPING = 64 | 0;

var SET_ALL = 255 | 0;

var UNSET_STATE = SET_ALL ^ (PENDING | ERROR | SUCCESS | AVERTED);

var SEALED = AVERTED | CONSUMED;

var Future = function() {
    function Future() {
        _classCallCheck(this, Future);
        this.d = PENDING;
        this.e = undefined;
        this.f = undefined;
        this.g = undefined;
        this.h = undefined;
        this.i = undefined;
        this.j = undefined;
        this.k = undefined;
    }
    Future.prototype.deref = function deref() {
        if (isSomeSet(this, ERROR)) {
            unset(this, PENDING_REJECTION);
            throw this.e;
        }
        return this.e;
    };
    Future.prototype.settle = function settle(error, result) {
        if (isNoneSet(this, PENDING) || isSomeSet(this, MAPPING)) return;
        if (error === this || result === this) {
            throw Error("A future can't be chained to itself");
        }
        this.k = undefined;
        if (error && isFuture(result)) {
            this.settle(error);
            return;
        }
        if (isFuture(error)) {
            if (error instanceof Future) {
                if (isSomeSet(error, SEALED)) {
                    this.settle(nonConsumableFutureError());
                    return;
                }
                linkPair(error, this);
                this.i = rethrow;
                return;
            }
            this.f = error.map(settleAtMappedError.bind(null, this));
            return;
        }
        if (isFuture(result)) {
            if (result instanceof Future) {
                if (isSomeSet(result, SEALED)) {
                    this.settle(nonConsumableFutureError());
                    return;
                }
                linkPair(result, this);
                return;
            }
            this.f = result.map(settleAtMappedResult.bind(null, this));
            return;
        }
        var mapper = this.i;
        this.i = undefined;
        if (isFunction(mapper)) {
            set(this, MAPPING);
            var mappedResult = undefined;
            try {
                mappedResult = mapper(error, result);
                unset(this, MAPPING);
            } catch (err) {
                unset(this, MAPPING);
                settleWithCaughtError(this, err);
                return;
            }
            this.settle(undefined, mappedResult);
            return;
        }
        replaceState(this, error ? ERROR : SUCCESS);
        this.e = error || result;
        if (this.g || this.h) {
            scheduleFuture(this);
            return;
        }
        if (error) {
            set(this, PENDING_REJECTION);
            scheduleFuture(this);
        }
    };
    Future.prototype.map = function map(fun) {
        validate(isFunction, fun);
        if (isSomeSet(this, SEALED)) throw nonConsumableFutureError();
        var nextInChain = new this.constructor();
        linkPair(this, nextInChain);
        nextInChain.i = fun;
        return nextInChain;
    };
    Future.prototype.mapError = function mapError(fun) {
        validate(isFunction, fun);
        return this.map(mapToError.bind(null, fun));
    };
    Future.prototype.mapResult = function mapResult(fun) {
        validate(isFunction, fun);
        return this.map(mapToResult.bind(null, fun));
    };
    Future.prototype.toPromise = function toPromise() {
        unset(this, PENDING_REJECTION);
        return isSomeSet(this, ERROR) ? Promise.reject(this.e) : isSomeSet(this, SUCCESS) ? Promise.resolve(this.e) : new Promise(mapFutureToPromise.bind(null, this));
    };
    Future.prototype.catch = function _catch() {
        var _toPromise;
        return (_toPromise = this.toPromise()).catch.apply(_toPromise, arguments);
    };
    Future.prototype.then = function then() {
        var _toPromise2;
        return (_toPromise2 = this.toPromise()).then.apply(_toPromise2, arguments);
    };
    Future.prototype.weak = function weak() {
        if (isSomeSet(this, AVERTED)) {
            throw Error("Can't create a .weak() branch from an averted future");
        }
        var Future = this.constructor;
        if (isSomeSet(this, ERROR)) return Future.fromError(this.e);
        if (isSomeSet(this, SUCCESS)) return Future.fromResult(this.e);
        if (!this.h) this.h = new Queue();
        var future = new Future();
        this.h.push(future);
        return future;
    };
    Future.prototype.finishPending = function finishPending() {
        if (this.j) {
            var initer = this.j;
            this.j = undefined;
            try {
                this.k = initer(this);
            } catch (err) {
                settleWithCaughtError(this, err);
            }
        }
        var nextInChain = this.g;
        if (nextInChain) {
            if (isSomeSet(this, ERROR)) {
                unlinkPair(this, nextInChain);
                nextInChain.settle(this.e);
            } else if (isSomeSet(this, SUCCESS)) {
                unlinkPair(this, nextInChain);
                nextInChain.settle(undefined, this.e);
            }
        }
        var weaks = this.h;
        if (weaks) {
            if (isSomeSet(this, ERROR)) {
                while (weaks.length) {
                    weaks.shift().settle(this.e);
                }
            } else if (isSomeSet(this, SUCCESS)) {
                while (weaks.length) {
                    weaks.shift().settle(undefined, this.e);
                }
            }
        }
        if (isSomeSet(this, PENDING_REJECTION)) {
            unset(this, PENDING_REJECTION);
            if (isSomeSet(this, ERROR)) {
                this.constructor.handleRejection(this);
            }
        }
    };
    Future.prototype.deinit = function deinit() {
        if (isSomeSet(this, AVERTED) || isSomeSet(this, MAPPING)) return;
        this.d = AVERTED;
        this.j = undefined;
        this.i = undefined;
        try {
            var deiniter = this.k;
            this.k = undefined;
            if (isFunction(deiniter)) deiniter();
        } finally {
            try {
                var prevInChain = this.f;
                this.f = undefined;
                if (prevInChain) prevInChain.deinit();
            } finally {
                try {
                    var nextInChain = this.g;
                    this.g = undefined;
                    if (nextInChain) nextInChain.deinit();
                } finally {
                    var weaks = this.h;
                    this.h = undefined;
                    if (weaks) forceDeinitFutureQue(weaks, _deinit);
                }
            }
        }
    };
    Future.init = function init(initer) {
        validate(isFunction, initer);
        var future = new this();
        try {
            future.k = initer(future);
        } catch (err) {
            settleWithCaughtError(future, err);
        }
        return future;
    };
    Future.initAsync = function initAsync(initer) {
        validate(isFunction, initer);
        var future = new this();
        future.j = initer;
        scheduleFuture(future);
        return future;
    };
    Future.from = function from(error, result) {
        var future = new this();
        future.settle(error, result);
        return future;
    };
    Future.fromError = function fromError(error) {
        validate(Boolean, error);
        return this.from(error);
    };
    Future.fromResult = function fromResult(result) {
        return isFuture(result) ? result : this.from(undefined, result);
    };
    Future.fromPromise = function fromPromise(promise) {
        validate(isPromise, promise);
        var future = new this();
        promise.then(future.settle.bind(future, undefined), future.settle.bind(future));
        return future;
    };
    Future.all = function all(values) {
        validate(isArray, values);
        if (!values.length) return this.fromResult([]);
        return new AllJunction(new this(), values.slice()).l;
    };
    Future.race = function race(values) {
        validate(isArray, values);
        return new RaceJunction(new this(), values.slice()).l;
    };
    Future.handleRejection = function handleRejection(future) {
        throw future.e;
    };
    _createClass(Future, [ {
        key: "state",
        get: function() {
            return {
                PENDING: isSomeSet(this, PENDING),
                ERROR: isSomeSet(this, ERROR),
                SUCCESS: isSomeSet(this, SUCCESS),
                AVERTED: isSomeSet(this, AVERTED),
                PENDING_REJECTION: isSomeSet(this, PENDING_REJECTION),
                CONSUMED: isSomeSet(this, CONSUMED),
                MAPPING: isSomeSet(this, MAPPING)
            };
        }
    } ]);
    return Future;
}();

Future.scheduler = new Scheduler();

exports.Future = Future;

var AllJunction = function() {
    function AllJunction(future, values) {
        _classCallCheck(this, AllJunction);
        this.l = future;
        this.m = values;
        future.k = this.n.bind(this);
        for (var i = -1; ++i < values.length; ) {
            var value = values[i];
            if (!isFuture(value)) continue;
            if (value instanceof Future) {
                if (isSomeSet(value, ERROR)) {
                    this.o(i, quetlyConsume(value));
                    return;
                }
                if (isSomeSet(value, SUCCESS)) {
                    values[i] = quetlyConsume(value);
                    continue;
                }
                if (!value.i) {
                    mapInPlace(value, this.o.bind(this, i));
                    continue;
                }
            }
            values[i] = value.map(this.o.bind(this, i));
        }
        this.p();
    }
    AllJunction.prototype.o = function settleAtIndex_(index, error, result) {
        var values = this.m;
        if (!values) return;
        if (error) {
            values[index] = undefined;
            this.l.settle(error);
            this.n();
            return;
        }
        values[index] = result;
        this.p();
    };
    AllJunction.prototype.p = function maybeSettle_() {
        var values = this.m;
        if (!values.some(isFuture)) {
            this.m = undefined;
            this.l.settle(undefined, values);
        }
    };
    AllJunction.prototype.n = function deinit_() {
        var values = this.m;
        this.m = undefined;
        if (values) forceDeinitMaybeFutures(values);
    };
    return AllJunction;
}();

var RaceJunction = function() {
    function RaceJunction(future, values) {
        _classCallCheck(this, RaceJunction);
        this.l = future;
        this.m = values;
        future.k = this.n.bind(this);
        for (var i = -1; ++i < values.length; ) {
            var value = values[i];
            if (!isFuture(value)) {
                this.o(i, undefined, value);
                return;
            }
            if (value instanceof Future) {
                if (isSomeSet(value, ERROR)) {
                    this.o(i, quetlyConsume(value));
                    return;
                }
                if (isSomeSet(value, SUCCESS)) {
                    this.o(i, undefined, quetlyConsume(value));
                    return;
                }
                if (!value.i) {
                    mapInPlace(value, this.o.bind(this, i));
                    continue;
                }
            }
            values[i] = value.map(this.o.bind(this, i));
        }
    }
    RaceJunction.prototype.o = function settleAtIndex_(index, error, result) {
        if (this.m) {
            this.m[index] = undefined;
            this.l.settle(error, result);
            this.n();
        }
    };
    RaceJunction.prototype.n = function deinit_() {
        var values = this.m;
        this.m = undefined;
        if (values) forceDeinitMaybeFutures(values);
    };
    return RaceJunction;
}();

function mapToError(fun, error, result) {
    return error ? fun(error) : result;
}

function mapToResult(fun, error, result) {
    if (error) throw error;
    return fun(result);
}

function settleAtMappedError(future, error, result) {
    future.f = undefined;
    future.settle(error || result);
}

function settleAtMappedResult(future, error, result) {
    future.f = undefined;
    future.settle(error, result);
}

function settleWithCaughtError(future, err) {
    if (isSomeSet(future, PENDING)) future.settle(err); else throw err;
}

function unlinkPair(prev, next) {
    prev.g = undefined;
    next.f = undefined;
}

function linkPair(prev, next) {
    prev.g = next;
    next.f = prev;
    unset(prev, PENDING_REJECTION);
    set(prev, CONSUMED);
    if (isNoneSet(prev, PENDING)) scheduleFuture(prev);
}

function quetlyConsume(future) {
    unset(future, PENDING_REJECTION);
    set(future, CONSUMED);
    return future.e;
}

function mapInPlace(future, fun) {
    unset(future, PENDING_REJECTION);
    set(future, CONSUMED);
    future.i = fun;
}

function mapFutureToPromise(future, resolve, reject) {
    future.map(function finalizeFuturePromise(error, result) {
        if (error) reject(error); else resolve(result);
    });
}

function scheduleFuture(future) {
    (future.constructor.scheduler || Future.scheduler).push(future);
}

function isDeinitable(value) {
    return isObject(value) && isFunction(value.deinit);
}

function isFunction(value) {
    return typeof value === "function";
}

function isArray(value) {
    return isObject(value) && value instanceof Array;
}

function isObject(value) {
    return value != null && typeof value === "object";
}

function isPromise(value) {
    return isObject(value) && isFunction(value.then);
}

function validate(test, value) {
    if (!test(value)) throw Error("Expected " + value + " to satisfy test " + test.name);
}

function rethrow(error, value) {
    throw error || value;
}

function nonConsumableFutureError() {
    return Error("Expected a consumable future (one that has not been averted or mapped)");
}

function _deinit(value) {
    if (isDeinitable(value)) value.deinit();
}

function forceDeinitFutureQue(list) {
    try {
        while (list.length) {
            list.shift().deinit();
        }
    } catch (err) {
        forceDeinitFutureQue(list);
        throw err;
    }
}

function forceDeinitMaybeFutures(list) {
    var error = null;
    for (var i = -1; ++i < list.length; ) {
        var value = list[i];
        if (isFuture(value)) {
            try {
                value.deinit();
            } catch (err) {
                error = err;
            }
        }
    }
    if (error) throw error;
}

function isSomeSet(future, bitmask) {
    return (future.d & bitmask) !== 0;
}

function isNoneSet(future, bitmask) {
    return (future.d & bitmask) === 0;
}

function set(future, bitmask) {
    future.d |= bitmask;
}

function unset(future, bitmask) {
    future.d &= ~bitmask;
}

function replaceState(future, bitmask) {
    future.d = future.d & UNSET_STATE | bitmask;
}

function chooseAsapImplementation(fun) {
    if (typeof self === "undefined" && typeof process === "object" && process && process.nextTick) {
        return process.nextTick;
    }
    if (typeof MessageChannel === "function") {
        var channel = new MessageChannel();
        channel.port1.onmessage = fun;
        return function asap() {
            channel.port2.postMessage(null);
        };
    }
    return setTimeout;
}