'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.call = call;
exports.apply = apply;
exports.bind = bind;
exports.applyBind = applyBind;
exports.curry1 = curry1;
exports.flip = flip;
exports.and = and;
exports.or = or;
exports.not = not;
exports.ifelse = ifelse;
exports.ifthen = ifthen;
exports.ifonly = ifonly;
exports.ifexists = ifexists;
exports.cond = cond;
exports.pipe = pipe;
exports.comp = comp;
exports.seq = seq;
exports.pipeAnd = pipeAnd;
exports.compAnd = compAnd;
exports.juxt = juxt;
exports.rest = rest;
exports.spread = spread;
exports.alter = alter;
exports.revise = revise;
exports.fanout = fanout;
exports.funnel = funnel;
exports.falsy = falsy;
exports.is = is;
exports.isNumber = isNumber;
exports.isFinite = isFinite;
exports.isInteger = isInteger;
exports.isNatural = isNatural;
exports.isNaN = isNaN;
exports.isString = isString;
exports.isBoolean = isBoolean;
exports.isSymbol = isSymbol;
exports.isPrimitive = isPrimitive;
exports.isComplex = isComplex;
exports.isInstance = isInstance;
exports.isFunction = isFunction;
exports.isObject = isObject;
exports.isDict = isDict;
exports.isArray = isArray;
exports.isList = isList;
exports.isRegExp = isRegExp;
exports.isDate = isDate;
exports.isValidDate = isValidDate;
exports.isInvalidDate = isInvalidDate;
exports.isPromise = isPromise;
exports.isNil = isNil;
exports.testBy = testBy;
exports.test = test;
exports.testAnd = testAnd;
exports.testOr = testOr;
exports.testArgsAnd = testArgsAnd;
exports.testArgsOr = testArgsOr;
exports.list = list;
exports.foldl = foldl;
exports.foldr = foldr;
exports.map = map;
exports.filter = filter;
exports.find = find;
exports.every = every;
exports.some = some;
exports.procure = procure;
exports.includes = includes;
exports.indexOf = indexOf;
exports.slice = slice;
exports.append = append;
exports.prepend = prepend;
exports.remove = remove;
exports.removeAtIndex = removeAtIndex;
exports.adjoin = adjoin;
exports.toggle = toggle;
exports.concat = concat;
exports.flat = flat;
exports.head = head;
exports.tail = tail;
exports.init = init;
exports.last = last;
exports.take = take;
exports.drop = drop;
exports.reverse = reverse;
exports.get = get;
exports.scan = scan;
exports.getIn = getIn;
exports.getAt = getAt;
exports.mapDict = mapDict;
exports.mapKeys = mapKeys;
exports.keys = keys;
exports.values = values;
exports.size = size;
exports.add = add;
exports.sub = sub;
exports.mul = mul;
exports.div = div;
exports.inc = inc;
exports.dec = dec;
exports.id = id;
exports.di = di;
exports.val = val;
exports.noop = noop;
exports.rethrow = rethrow;
exports.maskBy = maskBy;
exports.mask = mask;
exports.validate = validate;
exports.validateEach = validateEach;
/* eslint-disable no-invalid-this, prefer-spread */

var getPrototypeOf = Object.getPrototypeOf,
    protoObject = Object.prototype,
    getKeys = Object.keys;
var _Array$prototype = Array.prototype,
    nslice = _Array$prototype.slice,
    reduce = _Array$prototype.reduce,
    reduceRight = _Array$prototype.reduceRight,
    nmap = _Array$prototype.map,
    nfind = _Array$prototype.find,
    nfilter = _Array$prototype.filter,
    nevery = _Array$prototype.every,
    nsome = _Array$prototype.some;

// Fun

function call(fun) {
  validate(isFunction, fun);
  arguments[0] = this; // relies on strict mode
  return fun.call.apply(fun, arguments);
}

function apply(fun, args) {
  validate(isFunction, fun);
  validate(isList, args);
  return fun.apply(this, args);
}

// Much slower than a version that doesn't preserve "this"
// TODO figure out how to make it go faster, or abandon the preservation of "this"
function bind(fun) {
  return applyBind(fun, slice(arguments, 1));
}

function applyBind(fun, args) {
  validate(isFunction, fun);
  validate(isList, args);
  if (!isArray(args)) args = slice(args);
  return function bound() {
    return fun.apply(this, args.concat(slice(arguments)));
  };
}

function curry1(fun) {
  validate(isFunction, fun);
  return applyBind(bind, arguments);
}

function flip(fun) {
  validate(isFunction, fun);
  return function flip_() {
    return fun.apply(this, slice(arguments).reverse());
  };
}

// TODO should be expressed in terms of seq, or built from same primitives as seq
function and() {
  return compose(composeAnd, arguments);
}

function composeAnd(fun, funs) {
  return function and_() {
    return foldlWith.call(this, stepAnd, fun.apply(this, arguments), funs, arguments);
  };
}

function stepAnd(acc, fun, index, args) {
  return acc && fun.apply(this, args);
}

// TODO should be expressed in terms of seq, or built from same primitives as seq
function or() {
  return compose(composeOr, arguments);
}

function composeOr(fun, funs) {
  return function or_() {
    return foldlWith.call(this, stepOr, fun.apply(this, arguments), funs, arguments);
  };
}

function stepOr(acc, fun, index, args) {
  return acc || fun.apply(this, args);
}

function not(fun) {
  validate(isFunction, fun);
  return function not_() {
    return !fun.apply(this, arguments);
  };
}

function ifelse(test, left, right) {
  validate(isFunction, test);
  validate(isFunction, left);
  validate(isFunction, right);
  return function ifelse_() {
    return (test.apply(this, arguments) ? left : right).apply(this, arguments);
  };
}

function ifthen(test, fun) {
  return ifelse(test, fun, noop);
}

function ifonly(test, fun) {
  return ifelse(test, fun, id);
}

function ifexists(fun) {
  return ifthen(id, fun);
}

function cond(test, fun) {
  if (!arguments.length) return noop;
  validate(isFunction, test);
  if (arguments.length === 1) return test;
  return ifelse(test, fun, cond.apply(undefined, slice(arguments, 2)));
}

function pipe() {
  return compose(composePipe, arguments);
}

function composePipe(fun, funs) {
  return function pipe_() {
    return funs.reduce(callRight, fun.apply(this, arguments), this);
  };
}

function callRight(value, fun) {
  return fun.call(this, value);
}

function comp() {
  return pipe.apply(undefined, reverse(arguments));
}

function seq() {
  return compose(composeSeq, arguments);
}

function composeSeq(fun, funs) {
  return function seq_() {
    return foldlWith.call(this, stepSeq, fun.apply(this, arguments), funs, arguments);
  };
}

function stepSeq(_, fun, __, args) {
  return fun.apply(this, args);
}

function pipeAnd() {
  return compose(composePipeAnd, arguments);
}

function composePipeAnd(fun, funs) {
  return pipe(fun, function pipeAnd_(value) {
    return funs.reduce(stepPipeAnd, value, this);
  });
}

function stepPipeAnd(acc, fun) {
  return acc && fun.call(this, acc);
}

function compAnd() {
  return pipeAnd.apply(undefined, reverse(arguments));
}

function juxt() {
  var funs = slice(arguments);
  validateEach(isFunction, funs);
  return function juxt_() {
    return funs.map(applyRight.bind(this, arguments));
  };
}

function applyRight(args, fun) {
  return fun.apply(this, args);
}

function rest(fun) {
  validate(isFunction, fun);
  return function rest_() {
    return fun.call(this, slice(arguments));
  };
}

function spread(fun) {
  validate(isFunction, fun);
  return bind(apply, fun);
}

function alter(fun) {
  validate(isFunction, fun);
  return pipe(bind(prepend, slice(arguments, 1)), spread(fun));
}

function revise(transforms, fun) {
  validateEach(isFunction, transforms);
  validate(isFunction, fun);
  return function revise_() {
    return fun.apply(this, nmap.call(transforms, transmute, arguments));
  };
}

function transmute(fun, i) {
  return fun(this[i]);
}

function fanout(args, fun) {
  return pipe(juxt.apply(undefined, args), spread(fun));
}

function funnel(value, funs) {
  validateEach(isFunction, funs);
  return funs.reduce(callRight, value, this);
}

function compose(composerFun, funs) {
  if (!funs.length) return id;
  var fun = funs[0];
  validate(isFunction, fun);
  if (funs.length === 1) return fun;
  var rest = slice(funs, 1);
  validateEach(isFunction, rest);
  return composerFun(fun, rest);
}

// Bool

var bool = exports.bool = Boolean;
var truthy = exports.truthy = bool;
var negate = exports.negate = falsy;
function falsy(value) {
  return !value;
}

function is(one, other) {
  return one === other || isNaN(one) && isNaN(other);
}

function isNumber(value) {
  return typeof value === 'number';
}

function isFinite(value) {
  return isNumber(value) && !isNaN(value) && value !== Infinity && value !== -Infinity;
}

function isInteger(value) {
  return isFinite(value) && value % 1 === 0;
}

function isNatural(value) {
  return isInteger(value) && value >= 0;
}

function isNaN(value) {
  return value !== value; // eslint-disable-line no-self-compare
}

function isString(value) {
  return typeof value === 'string';
}

function isBoolean(value) {
  return typeof value === 'boolean';
}

function isSymbol(value) {
  return typeof value === 'symbol';
}

function isPrimitive(value) {
  return !isComplex(value);
}

function isComplex(value) {
  return isObject(value) || isFunction(value);
}

function isInstance(value, Class) {
  return isComplex(value) && value instanceof Class;
}

function isFunction(value) {
  return typeof value === 'function';
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}

var isPlainObject = exports.isPlainObject = isDict;
function isDict(value) {
  return isObject(value) && isPlainPrototype(getPrototypeOf(value));
}

// WTB better name, then publish and document.
// "Special object" has a special meaning in the ES spec, this ain't it.
function isSpecialObject(value) {
  return isObject(value) && (!isPlainPrototype(getPrototypeOf(value)) || isArguments(value));
}

// TODO consider documenting
function isArguments(value) {
  return isObject(value) && 'callee' in value && 'length' in value && isNatural(value.length);
}

function isPlainPrototype(value) {
  return value === null || value === protoObject;
}

function isArray(value) {
  return isInstance(value, Array);
}

function isList(value) {
  return isSpecialObject(value) && 'length' in value && isNatural(value.length);
}

function isRegExp(value) {
  return isInstance(value, RegExp);
}

function isDate(value) {
  return isInstance(value, Date);
}

function isValidDate(value) {
  return isDate(value) && isFinite(value.valueOf());
}

function isInvalidDate(value) {
  return isDate(value) && !isValidDate(value);
}

function isPromise(value) {
  return isComplex(value) && isFunction(value.then) && isFunction(value.catch);
}

function isNil(value) {
  return value == null;
}

function testBy(pattern, value) {
  return isFunction(pattern) ? pattern(value) : isPrimitive(pattern) ? is(pattern, value) : isRegExp(pattern) ? pattern.test(value) : isList(pattern) ? isList(value) && nevery.call(pattern, testByIndex, value) : isComplex(pattern) ? testComplex(pattern, value) : false;
}

function testByIndex(pattern, i) {
  return testBy(pattern, this[i]);
}

function testComplex(pattern, value) {
  if (!isComplex(value)) return false;
  for (var key in pattern) {
    if (!testBy(pattern[key], value[key])) return false;
  }return true;
}

function test(pattern) {
  return bind(testBy, pattern);
}

function testAnd() {
  return and.apply(undefined, map(test, arguments));
}

function testOr() {
  return or.apply(undefined, map(test, arguments));
}

function testArgsAnd() {
  return and.apply(undefined, map(test, arguments).map(pin));
}

function testArgsOr() {
  return or.apply(undefined, map(test, arguments).map(pin));
}

function pin(fun, i) {
  return function pin_() {
    return fun(arguments[i]);
  };
}

// List

function list() {
  return slice(arguments);
}

function foldl(fun, acc, list) {
  return reduce.call(toList(list), fun, acc, this);
}

function foldr(fun, acc, list) {
  return reduceRight.call(toList(list), fun, acc, this);
}

function foldlWith(fun, acc, list, a, b) {
  for (var i = -1; (i += 1) < list.length;) {
    acc = fun.call(this, acc, list[i], i, a, b);
  }return acc;
}

function map(fun, list) {
  validate(isFunction, fun);
  return nmap.call(toList(list), fun, this);
}

function filter(fun, list) {
  validate(isFunction, fun);
  return nfilter.call(toList(list), fun, this);
}

function find(fun, list) {
  validate(isFunction, fun);
  return nfind.call(toList(list), fun, this);
}

function every(fun, list) {
  validate(isFunction, fun);
  return nevery.call(toList(list), fun, this);
}

function some(fun, list) {
  validate(isFunction, fun);
  return nsome.call(toList(list), fun, this);
}

function procure(fun, list) {
  validate(isFunction, fun);
  list = toList(list);
  for (var i = -1; (i += 1) < list.length;) {
    var result = fun.call(this, list[i], i);
    if (result) return result;
  }
  return undefined;
}

function includes(list, value) {
  return indexOf(list, value) !== -1;
}

function indexOf(list, value) {
  if (!isList(list)) return -1;
  for (var i = -1; (i += 1) < list.length;) {
    if (is(list[i], value)) return i;
  }return -1;
}

function slice() {
  return nslice.call.apply(nslice, arguments);
}

function append(list, value) {
  return toArray(list).concat([value]);
}

function prepend(list, value) {
  return [value].concat(toArray(list));
}

function remove(list, value) {
  return removeAtIndex(list, indexOf(list, value));
}

function removeAtIndex(list, index) {
  list = toList(list);
  if (isNatural(index) && index < list.length) {
    list = slice(list);
    list.splice(index, 1);
  }
  return list;
}

function adjoin(list, value) {
  return includes(list, value) ? list : append(list, value);
}

function toggle(list, value) {
  return includes(list, value) ? remove(list, value) : append(list, value);
}

function concat() {
  return foldl(concatTwo, [], arguments);
}

function concatTwo(left, right) {
  return left.concat(toArray(right));
}

function flat(list) {
  return foldl(concatFlat, [], list);
}

function concatFlat(list, value) {
  return list.concat(isList(value) ? flat(value) : value);
}

var first = exports.first = head;
function head(list) {
  return isList(list) ? list[0] : undefined;
}

function tail(list) {
  return isList(list) ? slice(list, 1) : [];
}

function init(list) {
  return isList(list) ? slice(list, 0, -1) : [];
}

function last(list) {
  return isList(list) ? list[list.length - 1] : undefined;
}

function take(count, list) {
  validate(isNumber, count);
  return isList(list) ? slice(list, 0, count) : [];
}

function drop(count, list) {
  validate(isNumber, count);
  return isList(list) ? slice(list, count) : [];
}

function reverse(list) {
  return isList(list) ? slice(list).reverse() : [];
}

function toList(value) {
  return isList(value) ? value : [];
}

function toArray(value) {
  return isArray(value) ? value : isList(value) ? slice(value) : [];
}

// Dict

function get(value, key) {
  return value == null ? undefined : value[key];
}

function scan() {
  return arguments.length ? reduce.call(arguments, get) : undefined;
}

function getIn(value, path) {
  return reduce.call(path, get, value);
}

function getAt(path, value) {
  return reduce.call(path, get, value);
}

var mapVals = exports.mapVals = mapDict;
function mapDict(fun, value) {
  var out = {};
  for (var key in value) {
    out[key] = fun(value[key], key);
  }return out;
}

function mapKeys(fun, value) {
  var out = {};
  for (var key in value) {
    var prop = value[key];
    out[fun(prop, key)] = prop;
  }
  return out;
}

// Coll

function keys(value) {
  return isComplex(value) ? getKeys(value) : [];
}

function values(value) {
  return isArray(value) ? value : isList(value) ? slice(value) : isComplex(value) ? getKeys(value).map(bind(get, value)) : [];
}

// Note we're not using isComplex here; function size is 0
function size(value) {
  return isList(value) ? value.length : isObject(value) ? getKeys(value).length : 0;
}

// Ops

function add(a, b) {
  return a + b;
}
function sub(a, b) {
  return a - b;
}
function mul(a, b) {
  return a * b;
}
function div(a, b) {
  return a / b;
}
function inc(a) {
  return a + 1;
}
function dec(a) {
  return a - 1;
}

// Misc

function id(value) {
  return value;
}

function di(_, value) {
  return value;
}

function val(value) {
  return bind(id, value);
}

function noop() {}

function rethrow(val) {
  throw val;
}

function maskBy(pattern, value) {
  return isFunction(pattern) ? pattern(value) : isPrimitive(pattern) ? pattern : isRegExp(pattern) ? pattern.test(value) : isList(pattern) ? nmap.call(pattern, maskByIndex, isList(value) ? value : []) : isComplex(pattern) ? maskComplex(pattern, value) : undefined;
}

function maskByIndex(pattern, i) {
  return maskBy(pattern, this[i]);
}

function maskComplex(pattern, value) {
  var out = {};
  for (var key in pattern) {
    out[key] = maskBy(pattern[key], get(value, key));
  }return out;
}

function mask(pattern) {
  return bind(maskBy, pattern);
}

function validate(test, value) {
  if (!test(value)) throw Error('Expected ' + show(value) + ' to satisfy test ' + show(test));
}

function validateEach(test, list) {
  validate(isList, list);
  for (var i = -1; (i += 1) < list.length;) {
    if (!test(list[i])) {
      throw Error('Expected ' + show(list[i]) + ' at index ' + i + ' to satisfy test ' + show(test));
    }
  }
}

// Questionable
function show(value) {
  return isFunction(value) ? value.name || value.toString() : String(value);
}